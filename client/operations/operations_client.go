// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new operations API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for operations API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
ApplicationCreate creates application

This will create an application.
*/
func (a *Client) ApplicationCreate(params *ApplicationCreateParams, authInfo runtime.ClientAuthInfoWriter) (*ApplicationCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewApplicationCreateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ApplicationCreate",
		Method:             "POST",
		PathPattern:        "/application",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ApplicationCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ApplicationCreateOK), nil

}

/*
ApplicationDelete deletes application

This will delete the application with the given id.
*/
func (a *Client) ApplicationDelete(params *ApplicationDeleteParams, authInfo runtime.ClientAuthInfoWriter) (*ApplicationDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewApplicationDeleteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ApplicationDelete",
		Method:             "DELETE",
		PathPattern:        "/application/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ApplicationDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ApplicationDeleteOK), nil

}

/*
ApplicationGet gets application

This will get the application with the given id.
*/
func (a *Client) ApplicationGet(params *ApplicationGetParams, authInfo runtime.ClientAuthInfoWriter) (*ApplicationGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewApplicationGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ApplicationGet",
		Method:             "GET",
		PathPattern:        "/application/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ApplicationGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ApplicationGetOK), nil

}

/*
ApplicationList lists applications

This will retrieve all applications for a tenant.
*/
func (a *Client) ApplicationList(params *ApplicationListParams, authInfo runtime.ClientAuthInfoWriter) (*ApplicationListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewApplicationListParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ApplicationList",
		Method:             "GET",
		PathPattern:        "/applications",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ApplicationListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ApplicationListOK), nil

}

/*
ApplicationStatusList lists applications status

This will retrieve all applications status for a tenant.
*/
func (a *Client) ApplicationStatusList(params *ApplicationStatusListParams, authInfo runtime.ClientAuthInfoWriter) (*ApplicationStatusListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewApplicationStatusListParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ApplicationStatusList",
		Method:             "GET",
		PathPattern:        "/applicationstatus",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ApplicationStatusListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ApplicationStatusListOK), nil

}

/*
ApplicationUpdateV2 updates application

This will update an application.
*/
func (a *Client) ApplicationUpdateV2(params *ApplicationUpdateV2Params, authInfo runtime.ClientAuthInfoWriter) (*ApplicationUpdateV2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewApplicationUpdateV2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ApplicationUpdateV2",
		Method:             "PUT",
		PathPattern:        "/application/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ApplicationUpdateV2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ApplicationUpdateV2OK), nil

}

/*
CategoryCreate creates category

This will create a category.
*/
func (a *Client) CategoryCreate(params *CategoryCreateParams, authInfo runtime.ClientAuthInfoWriter) (*CategoryCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCategoryCreateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CategoryCreate",
		Method:             "POST",
		PathPattern:        "/categories",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CategoryCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CategoryCreateOK), nil

}

/*
CategoryDelete deletes category

This will delete the category with the given id.
*/
func (a *Client) CategoryDelete(params *CategoryDeleteParams, authInfo runtime.ClientAuthInfoWriter) (*CategoryDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCategoryDeleteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CategoryDelete",
		Method:             "DELETE",
		PathPattern:        "/categories/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CategoryDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CategoryDeleteOK), nil

}

/*
CategoryGet gets category

This will get the category with the given id.
*/
func (a *Client) CategoryGet(params *CategoryGetParams, authInfo runtime.ClientAuthInfoWriter) (*CategoryGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCategoryGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CategoryGet",
		Method:             "GET",
		PathPattern:        "/categories/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CategoryGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CategoryGetOK), nil

}

/*
CategoryList lists categories

This will retrieve all categories for a tenant.
*/
func (a *Client) CategoryList(params *CategoryListParams, authInfo runtime.ClientAuthInfoWriter) (*CategoryListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCategoryListParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CategoryList",
		Method:             "GET",
		PathPattern:        "/categories",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CategoryListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CategoryListOK), nil

}

/*
CategoryUpdateV2 updates category

This will update a category.
*/
func (a *Client) CategoryUpdateV2(params *CategoryUpdateV2Params, authInfo runtime.ClientAuthInfoWriter) (*CategoryUpdateV2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCategoryUpdateV2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CategoryUpdateV2",
		Method:             "PUT",
		PathPattern:        "/categories/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CategoryUpdateV2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CategoryUpdateV2OK), nil

}

/*
CertificatesCreate creates certificates

This will create certificates for devices.
*/
func (a *Client) CertificatesCreate(params *CertificatesCreateParams, authInfo runtime.ClientAuthInfoWriter) (*CertificatesCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCertificatesCreateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CertificatesCreate",
		Method:             "POST",
		PathPattern:        "/certificates",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CertificatesCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CertificatesCreateOK), nil

}

/*
CloudCredsCreate creates cloudcreds

This will create a cloudcreds.
*/
func (a *Client) CloudCredsCreate(params *CloudCredsCreateParams, authInfo runtime.ClientAuthInfoWriter) (*CloudCredsCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCloudCredsCreateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CloudCredsCreate",
		Method:             "POST",
		PathPattern:        "/cloudcreds",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CloudCredsCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CloudCredsCreateOK), nil

}

/*
CloudCredsDelete deletes cloudcreds

This will delete the cloudcreds with the given id.
*/
func (a *Client) CloudCredsDelete(params *CloudCredsDeleteParams, authInfo runtime.ClientAuthInfoWriter) (*CloudCredsDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCloudCredsDeleteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CloudCredsDelete",
		Method:             "DELETE",
		PathPattern:        "/cloudcreds/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CloudCredsDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CloudCredsDeleteOK), nil

}

/*
CloudCredsGet gets cloudcreds

This will get the cloudcreds with the given id.
*/
func (a *Client) CloudCredsGet(params *CloudCredsGetParams, authInfo runtime.ClientAuthInfoWriter) (*CloudCredsGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCloudCredsGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CloudCredsGet",
		Method:             "GET",
		PathPattern:        "/cloudcreds/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CloudCredsGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CloudCredsGetOK), nil

}

/*
CloudCredsList lists cloudcreds

This will retrieve all cloudcreds for a tenant.
*/
func (a *Client) CloudCredsList(params *CloudCredsListParams, authInfo runtime.ClientAuthInfoWriter) (*CloudCredsListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCloudCredsListParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CloudCredsList",
		Method:             "GET",
		PathPattern:        "/cloudcreds",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CloudCredsListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CloudCredsListOK), nil

}

/*
CloudCredsUpdateV2 updates cloudcreds

This will update a cloudcreds.
*/
func (a *Client) CloudCredsUpdateV2(params *CloudCredsUpdateV2Params, authInfo runtime.ClientAuthInfoWriter) (*CloudCredsUpdateV2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCloudCredsUpdateV2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CloudCredsUpdateV2",
		Method:             "PUT",
		PathPattern:        "/cloudcreds/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CloudCredsUpdateV2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CloudCredsUpdateV2OK), nil

}

/*
CommonAggregates performs aggregate query

This will get the results for the aggregate query.
*/
func (a *Client) CommonAggregates(params *CommonAggregatesParams, authInfo runtime.ClientAuthInfoWriter) (*CommonAggregatesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCommonAggregatesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CommonAggregates",
		Method:             "POST",
		PathPattern:        "/common/aggregates",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CommonAggregatesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CommonAggregatesOK), nil

}

/*
CommonNestedAggregates performs nested aggregate query

This will get the results for the nested aggregate query.
*/
func (a *Client) CommonNestedAggregates(params *CommonNestedAggregatesParams, authInfo runtime.ClientAuthInfoWriter) (*CommonNestedAggregatesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCommonNestedAggregatesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CommonNestedAggregates",
		Method:             "POST",
		PathPattern:        "/common/nestedAggregates",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CommonNestedAggregatesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CommonNestedAggregatesOK), nil

}

/*
ContainerRegistryCreate creates containerregistry

This will create a containerregistry.
*/
func (a *Client) ContainerRegistryCreate(params *ContainerRegistryCreateParams, authInfo runtime.ClientAuthInfoWriter) (*ContainerRegistryCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewContainerRegistryCreateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ContainerRegistryCreate",
		Method:             "POST",
		PathPattern:        "/containerregistries",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ContainerRegistryCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ContainerRegistryCreateOK), nil

}

/*
ContainerRegistryDelete deletes containerregistry

This will delete the containerregistries with the given id.
*/
func (a *Client) ContainerRegistryDelete(params *ContainerRegistryDeleteParams, authInfo runtime.ClientAuthInfoWriter) (*ContainerRegistryDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewContainerRegistryDeleteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ContainerRegistryDelete",
		Method:             "DELETE",
		PathPattern:        "/containerregistries/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ContainerRegistryDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ContainerRegistryDeleteOK), nil

}

/*
ContainerRegistryGet gets container registry

This will get the ContainerRegistry with the given id.
*/
func (a *Client) ContainerRegistryGet(params *ContainerRegistryGetParams, authInfo runtime.ClientAuthInfoWriter) (*ContainerRegistryGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewContainerRegistryGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ContainerRegistryGet",
		Method:             "GET",
		PathPattern:        "/containerregistries/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ContainerRegistryGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ContainerRegistryGetOK), nil

}

/*
ContainerRegistryList lists container registries

This will retrieve all ContainerRegistries for a tenant.
*/
func (a *Client) ContainerRegistryList(params *ContainerRegistryListParams, authInfo runtime.ClientAuthInfoWriter) (*ContainerRegistryListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewContainerRegistryListParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ContainerRegistryList",
		Method:             "GET",
		PathPattern:        "/containerregistries",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ContainerRegistryListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ContainerRegistryListOK), nil

}

/*
ContainerRegistryUpdate updates containerregistry

This will update a containerregistry.
*/
func (a *Client) ContainerRegistryUpdate(params *ContainerRegistryUpdateParams, authInfo runtime.ClientAuthInfoWriter) (*ContainerRegistryUpdateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewContainerRegistryUpdateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ContainerRegistryUpdate",
		Method:             "PUT",
		PathPattern:        "/containerregistries/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ContainerRegistryUpdateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ContainerRegistryUpdateOK), nil

}

/*
DataSourceCreate creates datasource

This will create a datasource.
*/
func (a *Client) DataSourceCreate(params *DataSourceCreateParams, authInfo runtime.ClientAuthInfoWriter) (*DataSourceCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDataSourceCreateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DataSourceCreate",
		Method:             "POST",
		PathPattern:        "/datasources",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DataSourceCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DataSourceCreateOK), nil

}

/*
DataSourceDelete deletes datasource

This will delete the datasource with the given id.
*/
func (a *Client) DataSourceDelete(params *DataSourceDeleteParams, authInfo runtime.ClientAuthInfoWriter) (*DataSourceDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDataSourceDeleteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DataSourceDelete",
		Method:             "DELETE",
		PathPattern:        "/datasources/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DataSourceDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DataSourceDeleteOK), nil

}

/*
DataSourceGet gets datasource

This will get the datasource with the given id.
*/
func (a *Client) DataSourceGet(params *DataSourceGetParams, authInfo runtime.ClientAuthInfoWriter) (*DataSourceGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDataSourceGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DataSourceGet",
		Method:             "GET",
		PathPattern:        "/datasources/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DataSourceGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DataSourceGetOK), nil

}

/*
DataSourceList lists datasources

This will retrieve all datasources for a tenant.
*/
func (a *Client) DataSourceList(params *DataSourceListParams, authInfo runtime.ClientAuthInfoWriter) (*DataSourceListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDataSourceListParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DataSourceList",
		Method:             "GET",
		PathPattern:        "/datasources",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DataSourceListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DataSourceListOK), nil

}

/*
DataSourceUpdateV2 updates datasource

This will update a datasource. DataSource edgeId can't be changed in update.
*/
func (a *Client) DataSourceUpdateV2(params *DataSourceUpdateV2Params, authInfo runtime.ClientAuthInfoWriter) (*DataSourceUpdateV2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDataSourceUpdateV2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DataSourceUpdateV2",
		Method:             "PUT",
		PathPattern:        "/datasources/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DataSourceUpdateV2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DataSourceUpdateV2OK), nil

}

/*
DataStreamCreate creates datastream

This will create a datastream.
*/
func (a *Client) DataStreamCreate(params *DataStreamCreateParams, authInfo runtime.ClientAuthInfoWriter) (*DataStreamCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDataStreamCreateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DataStreamCreate",
		Method:             "POST",
		PathPattern:        "/datastreams",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DataStreamCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DataStreamCreateOK), nil

}

/*
DataStreamDelete deletes datastream

This will delete the datastream with the given id.
*/
func (a *Client) DataStreamDelete(params *DataStreamDeleteParams, authInfo runtime.ClientAuthInfoWriter) (*DataStreamDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDataStreamDeleteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DataStreamDelete",
		Method:             "DELETE",
		PathPattern:        "/datastreams/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DataStreamDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DataStreamDeleteOK), nil

}

/*
DataStreamGet gets datastream

This will get the datastream with the given id.
*/
func (a *Client) DataStreamGet(params *DataStreamGetParams, authInfo runtime.ClientAuthInfoWriter) (*DataStreamGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDataStreamGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DataStreamGet",
		Method:             "GET",
		PathPattern:        "/datastreams/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DataStreamGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DataStreamGetOK), nil

}

/*
DataStreamList lists datastreams

This will retrieve all datastreams for a tenant.
*/
func (a *Client) DataStreamList(params *DataStreamListParams, authInfo runtime.ClientAuthInfoWriter) (*DataStreamListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDataStreamListParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DataStreamList",
		Method:             "GET",
		PathPattern:        "/datastreams",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DataStreamListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DataStreamListOK), nil

}

/*
DataStreamUpdateV2 updates datstream

This will update a datastream.
*/
func (a *Client) DataStreamUpdateV2(params *DataStreamUpdateV2Params, authInfo runtime.ClientAuthInfoWriter) (*DataStreamUpdateV2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDataStreamUpdateV2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DataStreamUpdateV2",
		Method:             "PUT",
		PathPattern:        "/datastreams/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DataStreamUpdateV2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DataStreamUpdateV2OK), nil

}

/*
DockerProfileCreate creates dockerprofiles

This will create a dockerprofiles.
*/
func (a *Client) DockerProfileCreate(params *DockerProfileCreateParams, authInfo runtime.ClientAuthInfoWriter) (*DockerProfileCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDockerProfileCreateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DockerProfileCreate",
		Method:             "POST",
		PathPattern:        "/dockerprofiles",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DockerProfileCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DockerProfileCreateOK), nil

}

/*
DockerProfileDelete deletes dockerprofiles

This will delete the dockerprofiles with the given id.
*/
func (a *Client) DockerProfileDelete(params *DockerProfileDeleteParams, authInfo runtime.ClientAuthInfoWriter) (*DockerProfileDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDockerProfileDeleteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DockerProfileDelete",
		Method:             "DELETE",
		PathPattern:        "/dockerprofiles/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DockerProfileDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DockerProfileDeleteOK), nil

}

/*
DockerProfileGet gets dockerprofiles

This will get the dockerProfiles with the given id.
*/
func (a *Client) DockerProfileGet(params *DockerProfileGetParams, authInfo runtime.ClientAuthInfoWriter) (*DockerProfileGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDockerProfileGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DockerProfileGet",
		Method:             "GET",
		PathPattern:        "/dockerprofiles/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DockerProfileGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DockerProfileGetOK), nil

}

/*
DockerProfileList lists docker profiles

This will retrieve all DockerProfiles for a tenant.
*/
func (a *Client) DockerProfileList(params *DockerProfileListParams, authInfo runtime.ClientAuthInfoWriter) (*DockerProfileListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDockerProfileListParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DockerProfileList",
		Method:             "GET",
		PathPattern:        "/dockerprofiles",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DockerProfileListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DockerProfileListOK), nil

}

/*
DockerProfileUpdateV2 updates dockerprofiles

This will update a dockerprofiles.
*/
func (a *Client) DockerProfileUpdateV2(params *DockerProfileUpdateV2Params, authInfo runtime.ClientAuthInfoWriter) (*DockerProfileUpdateV2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDockerProfileUpdateV2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DockerProfileUpdateV2",
		Method:             "PUT",
		PathPattern:        "/dockerprofiles/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DockerProfileUpdateV2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DockerProfileUpdateV2OK), nil

}

/*
EdgeCreate creates edge

This will create an edge.
*/
func (a *Client) EdgeCreate(params *EdgeCreateParams, authInfo runtime.ClientAuthInfoWriter) (*EdgeCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEdgeCreateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "EdgeCreate",
		Method:             "POST",
		PathPattern:        "/edges",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &EdgeCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*EdgeCreateOK), nil

}

/*
EdgeDelete deletes edge

This will delete the edge with the given id.
*/
func (a *Client) EdgeDelete(params *EdgeDeleteParams, authInfo runtime.ClientAuthInfoWriter) (*EdgeDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEdgeDeleteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "EdgeDelete",
		Method:             "DELETE",
		PathPattern:        "/edges/{edgeId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &EdgeDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*EdgeDeleteOK), nil

}

/*
EdgeGet gets edge

This will get the edge with the given id.
*/
func (a *Client) EdgeGet(params *EdgeGetParams, authInfo runtime.ClientAuthInfoWriter) (*EdgeGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEdgeGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "EdgeGet",
		Method:             "GET",
		PathPattern:        "/edges/{edgeId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &EdgeGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*EdgeGetOK), nil

}

/*
EdgeGetBySerialNumber gets edge by serial number

This will get the edge with the given serial number.
*/
func (a *Client) EdgeGetBySerialNumber(params *EdgeGetBySerialNumberParams, authInfo runtime.ClientAuthInfoWriter) (*EdgeGetBySerialNumberOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEdgeGetBySerialNumberParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "EdgeGetBySerialNumber",
		Method:             "POST",
		PathPattern:        "/edgebyserialnumber",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &EdgeGetBySerialNumberReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*EdgeGetBySerialNumberOK), nil

}

/*
EdgeGetDatasources lists edge datasources

This will retrieve all datasources for an edge of a tenant.
*/
func (a *Client) EdgeGetDatasources(params *EdgeGetDatasourcesParams, authInfo runtime.ClientAuthInfoWriter) (*EdgeGetDatasourcesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEdgeGetDatasourcesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "EdgeGetDatasources",
		Method:             "GET",
		PathPattern:        "/edges/{edgeId}/datasources",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &EdgeGetDatasourcesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*EdgeGetDatasourcesOK), nil

}

/*
EdgeGetHandle gets edge handle

This will get the certificate and private key for the edge.
*/
func (a *Client) EdgeGetHandle(params *EdgeGetHandleParams, authInfo runtime.ClientAuthInfoWriter) (*EdgeGetHandleOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEdgeGetHandleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "EdgeGetHandle",
		Method:             "POST",
		PathPattern:        "/edgehandle/{edgeId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &EdgeGetHandleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*EdgeGetHandleOK), nil

}

/*
EdgeGetSensors lists edge sensors

This will retrieve all sensors for an edge of a tenant.
*/
func (a *Client) EdgeGetSensors(params *EdgeGetSensorsParams, authInfo runtime.ClientAuthInfoWriter) (*EdgeGetSensorsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEdgeGetSensorsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "EdgeGetSensors",
		Method:             "GET",
		PathPattern:        "/edges/{edgeId}/sensors",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &EdgeGetSensorsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*EdgeGetSensorsOK), nil

}

/*
EdgeGetUpgrades this will get possible upgrades using edge ID
*/
func (a *Client) EdgeGetUpgrades(params *EdgeGetUpgradesParams, authInfo runtime.ClientAuthInfoWriter) (*EdgeGetUpgradesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEdgeGetUpgradesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "EdgeGetUpgrades",
		Method:             "GET",
		PathPattern:        "/edges/{edgeId}/upgradecompatible",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &EdgeGetUpgradesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*EdgeGetUpgradesOK), nil

}

/*
EdgeInfoGet gets edge info with edge id

This will retrieve edgeinfo for a edge.
*/
func (a *Client) EdgeInfoGet(params *EdgeInfoGetParams, authInfo runtime.ClientAuthInfoWriter) (*EdgeInfoGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEdgeInfoGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "EdgeInfoGet",
		Method:             "GET",
		PathPattern:        "/edges/{edgeId}/info",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &EdgeInfoGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*EdgeInfoGetOK), nil

}

/*
EdgeInfoList lists edge info

This will retrieve all edgeinfo for a tenant.
*/
func (a *Client) EdgeInfoList(params *EdgeInfoListParams, authInfo runtime.ClientAuthInfoWriter) (*EdgeInfoListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEdgeInfoListParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "EdgeInfoList",
		Method:             "GET",
		PathPattern:        "/edgesInfo",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &EdgeInfoListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*EdgeInfoListOK), nil

}

/*
EdgeInfoUpdate updates edge info with edge id

This will update edgeinfo for an edge.
*/
func (a *Client) EdgeInfoUpdate(params *EdgeInfoUpdateParams, authInfo runtime.ClientAuthInfoWriter) (*EdgeInfoUpdateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEdgeInfoUpdateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "EdgeInfoUpdate",
		Method:             "PUT",
		PathPattern:        "/edges/{id}/info",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &EdgeInfoUpdateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*EdgeInfoUpdateOK), nil

}

/*
EdgeList lists edges

This will retrieve all edges for a tenant.
*/
func (a *Client) EdgeList(params *EdgeListParams, authInfo runtime.ClientAuthInfoWriter) (*EdgeListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEdgeListParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "EdgeList",
		Method:             "GET",
		PathPattern:        "/edges",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &EdgeListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*EdgeListOK), nil

}

/*
EdgeUpdateV2 updates edge

This will update an edge.
*/
func (a *Client) EdgeUpdateV2(params *EdgeUpdateV2Params, authInfo runtime.ClientAuthInfoWriter) (*EdgeUpdateV2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEdgeUpdateV2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "EdgeUpdateV2",
		Method:             "PUT",
		PathPattern:        "/edges/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &EdgeUpdateV2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*EdgeUpdateV2OK), nil

}

/*
EdgeUpgradeList lists upgrades available
*/
func (a *Client) EdgeUpgradeList(params *EdgeUpgradeListParams, authInfo runtime.ClientAuthInfoWriter) (*EdgeUpgradeListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEdgeUpgradeListParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "EdgeUpgradeList",
		Method:             "GET",
		PathPattern:        "/edgesCompatibleUpgrades",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &EdgeUpgradeListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*EdgeUpgradeListOK), nil

}

/*
ExecuteEdgeUpgrade executes edge upgrade
*/
func (a *Client) ExecuteEdgeUpgrade(params *ExecuteEdgeUpgradeParams, authInfo runtime.ClientAuthInfoWriter) (*ExecuteEdgeUpgradeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExecuteEdgeUpgradeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ExecuteEdgeUpgrade",
		Method:             "POST",
		PathPattern:        "/edges/upgrade",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ExecuteEdgeUpgradeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ExecuteEdgeUpgradeOK), nil

}

/*
LogEntriesList lists log entries

This will retrieve all log entries for a tenant.
*/
func (a *Client) LogEntriesList(params *LogEntriesListParams, authInfo runtime.ClientAuthInfoWriter) (*LogEntriesListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLogEntriesListParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "LogEntriesList",
		Method:             "GET",
		PathPattern:        "/logs/entries",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &LogEntriesListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*LogEntriesListOK), nil

}

/*
LogEntryDelete deletes log entry

This will delete the log entry with the given id.
*/
func (a *Client) LogEntryDelete(params *LogEntryDeleteParams, authInfo runtime.ClientAuthInfoWriter) (*LogEntryDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLogEntryDeleteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "LogEntryDelete",
		Method:             "DELETE",
		PathPattern:        "/logs/entries/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &LogEntryDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*LogEntryDeleteOK), nil

}

/*
LogRequestDownload requests log download

Generate the log download URL
*/
func (a *Client) LogRequestDownload(params *LogRequestDownloadParams, authInfo runtime.ClientAuthInfoWriter) (*LogRequestDownloadOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLogRequestDownloadParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "LogRequestDownload",
		Method:             "POST",
		PathPattern:        "/logs/requestDownload",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &LogRequestDownloadReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*LogRequestDownloadOK), nil

}

/*
LogRequestUpload requests log upload

Request edges to upload logs to S3.
*/
func (a *Client) LogRequestUpload(params *LogRequestUploadParams, authInfo runtime.ClientAuthInfoWriter) (*LogRequestUploadOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLogRequestUploadParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "LogRequestUpload",
		Method:             "POST",
		PathPattern:        "/logs/requestUpload",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &LogRequestUploadReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*LogRequestUploadOK), nil

}

/*
LogUploadComplete reports log upload complete

Edge will use this API to notify log upload complete.
*/
func (a *Client) LogUploadComplete(params *LogUploadCompleteParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLogUploadCompleteParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "LogUploadComplete",
		Method:             "POST",
		PathPattern:        "/logs/uploadComplete",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &LogUploadCompleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
LoginCall logins user

This will log the user in.
*/
func (a *Client) LoginCall(params *LoginCallParams) (*LoginCallOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLoginCallParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "LoginCall",
		Method:             "POST",
		PathPattern:        "/login",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &LoginCallReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*LoginCallOK), nil

}

/*
OAuthAuthorizeCall logins via my nutanix

This will redirect the user to the oauth login page.
Note: UI only API
*/
func (a *Client) OAuthAuthorizeCall(params *OAuthAuthorizeCallParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewOAuthAuthorizeCallParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "OAuthAuthorizeCall",
		Method:             "GET",
		PathPattern:        "/oauth2/authorize",
		ProducesMediaTypes: []string{"application/html"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &OAuthAuthorizeCallReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
OAuthTokenCall refreshes token via my nutanix

This will get the session token from the auth token.
Note: UI only API
*/
func (a *Client) OAuthTokenCall(params *OAuthTokenCallParams) (*OAuthTokenCallOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewOAuthTokenCallParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "OAuthTokenCall",
		Method:             "POST",
		PathPattern:        "/oauth2/token",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &OAuthTokenCallReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*OAuthTokenCallOK), nil

}

/*
ProjectCreate creates project

This will create a project.
*/
func (a *Client) ProjectCreate(params *ProjectCreateParams, authInfo runtime.ClientAuthInfoWriter) (*ProjectCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewProjectCreateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ProjectCreate",
		Method:             "POST",
		PathPattern:        "/projects",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ProjectCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ProjectCreateOK), nil

}

/*
ProjectDelete deletes project

This will delete the project with the given id.
*/
func (a *Client) ProjectDelete(params *ProjectDeleteParams, authInfo runtime.ClientAuthInfoWriter) (*ProjectDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewProjectDeleteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ProjectDelete",
		Method:             "DELETE",
		PathPattern:        "/projects/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ProjectDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ProjectDeleteOK), nil

}

/*
ProjectGet gets project

This will get the project with the given id.
*/
func (a *Client) ProjectGet(params *ProjectGetParams, authInfo runtime.ClientAuthInfoWriter) (*ProjectGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewProjectGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ProjectGet",
		Method:             "GET",
		PathPattern:        "/projects/{projectId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ProjectGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ProjectGetOK), nil

}

/*
ProjectGetApplications lists project applications

This will retrieve all applications for a project of a tenant.
*/
func (a *Client) ProjectGetApplications(params *ProjectGetApplicationsParams, authInfo runtime.ClientAuthInfoWriter) (*ProjectGetApplicationsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewProjectGetApplicationsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ProjectGetApplications",
		Method:             "GET",
		PathPattern:        "/projects/{projectId}/applications",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ProjectGetApplicationsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ProjectGetApplicationsOK), nil

}

/*
ProjectGetCloudCreds lists project cloudcreds

This will retrieve all cloudcreds for a project of a tenant.
*/
func (a *Client) ProjectGetCloudCreds(params *ProjectGetCloudCredsParams, authInfo runtime.ClientAuthInfoWriter) (*ProjectGetCloudCredsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewProjectGetCloudCredsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ProjectGetCloudCreds",
		Method:             "GET",
		PathPattern:        "/projects/{projectId}/cloudcreds",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ProjectGetCloudCredsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ProjectGetCloudCredsOK), nil

}

/*
ProjectGetContainerRegistries lists project container registries

This will retrieve all ContainerRegistries for a project of a tenant.
*/
func (a *Client) ProjectGetContainerRegistries(params *ProjectGetContainerRegistriesParams, authInfo runtime.ClientAuthInfoWriter) (*ProjectGetContainerRegistriesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewProjectGetContainerRegistriesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ProjectGetContainerRegistries",
		Method:             "GET",
		PathPattern:        "/projects/{projectId}/containerregistries",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ProjectGetContainerRegistriesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ProjectGetContainerRegistriesOK), nil

}

/*
ProjectGetDataStreams lists project datastreams

This will retrieve all datastreams for a project of a tenant.
*/
func (a *Client) ProjectGetDataStreams(params *ProjectGetDataStreamsParams, authInfo runtime.ClientAuthInfoWriter) (*ProjectGetDataStreamsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewProjectGetDataStreamsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ProjectGetDataStreams",
		Method:             "GET",
		PathPattern:        "/projects/{projectId}/datastreams",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ProjectGetDataStreamsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ProjectGetDataStreamsOK), nil

}

/*
ProjectGetDatasources lists project datasources

This will retrieve all datasources for a project of a tenant.
*/
func (a *Client) ProjectGetDatasources(params *ProjectGetDatasourcesParams, authInfo runtime.ClientAuthInfoWriter) (*ProjectGetDatasourcesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewProjectGetDatasourcesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ProjectGetDatasources",
		Method:             "GET",
		PathPattern:        "/projects/{projectId}/datasources",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ProjectGetDatasourcesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ProjectGetDatasourcesOK), nil

}

/*
ProjectGetDockerProfiles lists project docker profiles

This will retrieve all DockerProfiles for a project of a tenant.
*/
func (a *Client) ProjectGetDockerProfiles(params *ProjectGetDockerProfilesParams, authInfo runtime.ClientAuthInfoWriter) (*ProjectGetDockerProfilesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewProjectGetDockerProfilesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ProjectGetDockerProfiles",
		Method:             "GET",
		PathPattern:        "/projects/{projectId}/dockerprofiles",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ProjectGetDockerProfilesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ProjectGetDockerProfilesOK), nil

}

/*
ProjectGetEdges lists project edges

This will retrieve all edges for a project of a tenant.
*/
func (a *Client) ProjectGetEdges(params *ProjectGetEdgesParams, authInfo runtime.ClientAuthInfoWriter) (*ProjectGetEdgesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewProjectGetEdgesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ProjectGetEdges",
		Method:             "GET",
		PathPattern:        "/projects/{projectId}/edges",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ProjectGetEdgesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ProjectGetEdgesOK), nil

}

/*
ProjectGetScriptRuntimes lists project scriptruntimes

This will retrieve all scriptruntimes for a project of a tenant.
*/
func (a *Client) ProjectGetScriptRuntimes(params *ProjectGetScriptRuntimesParams, authInfo runtime.ClientAuthInfoWriter) (*ProjectGetScriptRuntimesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewProjectGetScriptRuntimesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ProjectGetScriptRuntimes",
		Method:             "GET",
		PathPattern:        "/projects/{projectId}/scriptruntimes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ProjectGetScriptRuntimesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ProjectGetScriptRuntimesOK), nil

}

/*
ProjectGetScripts lists project scripts

This will retrieve all scripts for a project of a tenant.
*/
func (a *Client) ProjectGetScripts(params *ProjectGetScriptsParams, authInfo runtime.ClientAuthInfoWriter) (*ProjectGetScriptsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewProjectGetScriptsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ProjectGetScripts",
		Method:             "GET",
		PathPattern:        "/projects/{projectId}/scripts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ProjectGetScriptsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ProjectGetScriptsOK), nil

}

/*
ProjectGetUsers lists project users

This will retrieve all users for a project of a tenant.
*/
func (a *Client) ProjectGetUsers(params *ProjectGetUsersParams, authInfo runtime.ClientAuthInfoWriter) (*ProjectGetUsersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewProjectGetUsersParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ProjectGetUsers",
		Method:             "GET",
		PathPattern:        "/projects/{projectId}/users",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ProjectGetUsersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ProjectGetUsersOK), nil

}

/*
ProjectList lists projects

This will retrieve all projects for a tenant.
*/
func (a *Client) ProjectList(params *ProjectListParams, authInfo runtime.ClientAuthInfoWriter) (*ProjectListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewProjectListParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ProjectList",
		Method:             "GET",
		PathPattern:        "/projects",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ProjectListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ProjectListOK), nil

}

/*
ProjectUpdateV2 updates project

This will update a project.
*/
func (a *Client) ProjectUpdateV2(params *ProjectUpdateV2Params, authInfo runtime.ClientAuthInfoWriter) (*ProjectUpdateV2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewProjectUpdateV2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ProjectUpdateV2",
		Method:             "PUT",
		PathPattern:        "/projects/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ProjectUpdateV2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ProjectUpdateV2OK), nil

}

/*
QueryEvents lists events

This will retrieve all events matching the filter for a tenant
*/
func (a *Client) QueryEvents(params *QueryEventsParams, authInfo runtime.ClientAuthInfoWriter) (*QueryEventsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQueryEventsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "QueryEvents",
		Method:             "POST",
		PathPattern:        "/events",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &QueryEventsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*QueryEventsOK), nil

}

/*
ScriptCreate creates script

This will create a script.
*/
func (a *Client) ScriptCreate(params *ScriptCreateParams, authInfo runtime.ClientAuthInfoWriter) (*ScriptCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewScriptCreateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ScriptCreate",
		Method:             "POST",
		PathPattern:        "/scripts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ScriptCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ScriptCreateOK), nil

}

/*
ScriptDelete deletes script

This will delete the script with the given id.
*/
func (a *Client) ScriptDelete(params *ScriptDeleteParams, authInfo runtime.ClientAuthInfoWriter) (*ScriptDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewScriptDeleteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ScriptDelete",
		Method:             "DELETE",
		PathPattern:        "/scripts/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ScriptDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ScriptDeleteOK), nil

}

/*
ScriptGet gets script

This will get the script with the given id.
*/
func (a *Client) ScriptGet(params *ScriptGetParams, authInfo runtime.ClientAuthInfoWriter) (*ScriptGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewScriptGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ScriptGet",
		Method:             "GET",
		PathPattern:        "/scripts/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ScriptGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ScriptGetOK), nil

}

/*
ScriptList lists scripts

This will retrieve all scripts for a tenant.
*/
func (a *Client) ScriptList(params *ScriptListParams, authInfo runtime.ClientAuthInfoWriter) (*ScriptListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewScriptListParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ScriptList",
		Method:             "GET",
		PathPattern:        "/scripts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ScriptListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ScriptListOK), nil

}

/*
ScriptRuntimeCreate creates script runtime

This will create a script runtime.
*/
func (a *Client) ScriptRuntimeCreate(params *ScriptRuntimeCreateParams, authInfo runtime.ClientAuthInfoWriter) (*ScriptRuntimeCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewScriptRuntimeCreateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ScriptRuntimeCreate",
		Method:             "POST",
		PathPattern:        "/scriptruntimes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ScriptRuntimeCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ScriptRuntimeCreateOK), nil

}

/*
ScriptRuntimeDelete deletes script runtime

This will delete the script runtime with the given id.
*/
func (a *Client) ScriptRuntimeDelete(params *ScriptRuntimeDeleteParams, authInfo runtime.ClientAuthInfoWriter) (*ScriptRuntimeDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewScriptRuntimeDeleteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ScriptRuntimeDelete",
		Method:             "DELETE",
		PathPattern:        "/scriptruntimes/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ScriptRuntimeDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ScriptRuntimeDeleteOK), nil

}

/*
ScriptRuntimeGet gets script runtime

This will get the script runtime with the given id.
*/
func (a *Client) ScriptRuntimeGet(params *ScriptRuntimeGetParams, authInfo runtime.ClientAuthInfoWriter) (*ScriptRuntimeGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewScriptRuntimeGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ScriptRuntimeGet",
		Method:             "GET",
		PathPattern:        "/scriptruntimes/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ScriptRuntimeGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ScriptRuntimeGetOK), nil

}

/*
ScriptRuntimeList lists script runtimes

This will retrieve all script runtimes for a tenant.
*/
func (a *Client) ScriptRuntimeList(params *ScriptRuntimeListParams, authInfo runtime.ClientAuthInfoWriter) (*ScriptRuntimeListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewScriptRuntimeListParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ScriptRuntimeList",
		Method:             "GET",
		PathPattern:        "/scriptruntimes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ScriptRuntimeListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ScriptRuntimeListOK), nil

}

/*
ScriptRuntimeUpdateV2 updates script runtime

This will update a script runtime.
*/
func (a *Client) ScriptRuntimeUpdateV2(params *ScriptRuntimeUpdateV2Params, authInfo runtime.ClientAuthInfoWriter) (*ScriptRuntimeUpdateV2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewScriptRuntimeUpdateV2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ScriptRuntimeUpdateV2",
		Method:             "PUT",
		PathPattern:        "/scriptruntimes/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ScriptRuntimeUpdateV2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ScriptRuntimeUpdateV2OK), nil

}

/*
ScriptUpdateV2 updates script

This will update a script.
*/
func (a *Client) ScriptUpdateV2(params *ScriptUpdateV2Params, authInfo runtime.ClientAuthInfoWriter) (*ScriptUpdateV2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewScriptUpdateV2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ScriptUpdateV2",
		Method:             "PUT",
		PathPattern:        "/scripts/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ScriptUpdateV2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ScriptUpdateV2OK), nil

}

/*
SensorCreate creates sensor

This will create a sensor.
*/
func (a *Client) SensorCreate(params *SensorCreateParams, authInfo runtime.ClientAuthInfoWriter) (*SensorCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSensorCreateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "SensorCreate",
		Method:             "POST",
		PathPattern:        "/sensors",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SensorCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SensorCreateOK), nil

}

/*
SensorDelete deletes sensor

This will delete the sensor with the given id.
*/
func (a *Client) SensorDelete(params *SensorDeleteParams, authInfo runtime.ClientAuthInfoWriter) (*SensorDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSensorDeleteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "SensorDelete",
		Method:             "DELETE",
		PathPattern:        "/sensors/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SensorDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SensorDeleteOK), nil

}

/*
SensorGet gets sensor

This will get the sensor with the given id.
*/
func (a *Client) SensorGet(params *SensorGetParams, authInfo runtime.ClientAuthInfoWriter) (*SensorGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSensorGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "SensorGet",
		Method:             "GET",
		PathPattern:        "/sensors/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SensorGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SensorGetOK), nil

}

/*
SensorList lists sensors

This will retrieve all sensors for a tenant.
*/
func (a *Client) SensorList(params *SensorListParams, authInfo runtime.ClientAuthInfoWriter) (*SensorListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSensorListParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "SensorList",
		Method:             "GET",
		PathPattern:        "/sensors",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SensorListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SensorListOK), nil

}

/*
SensorUpdateV2 updates sensor

This will update a sensor.
*/
func (a *Client) SensorUpdateV2(params *SensorUpdateV2Params, authInfo runtime.ClientAuthInfoWriter) (*SensorUpdateV2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSensorUpdateV2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "SensorUpdateV2",
		Method:             "PUT",
		PathPattern:        "/sensors/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SensorUpdateV2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SensorUpdateV2OK), nil

}

/*
TenantPropsDelete deletes tenant properties

This will delete the properties for the tenant with the given id.
*/
func (a *Client) TenantPropsDelete(params *TenantPropsDeleteParams, authInfo runtime.ClientAuthInfoWriter) (*TenantPropsDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTenantPropsDeleteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "TenantPropsDelete",
		Method:             "DELETE",
		PathPattern:        "/tenantprops/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &TenantPropsDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*TenantPropsDeleteOK), nil

}

/*
TenantPropsGet gets tenant properties

This will get the properties for the tenant with the given id.
*/
func (a *Client) TenantPropsGet(params *TenantPropsGetParams, authInfo runtime.ClientAuthInfoWriter) (*TenantPropsGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTenantPropsGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "TenantPropsGet",
		Method:             "GET",
		PathPattern:        "/tenantprops/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &TenantPropsGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*TenantPropsGetOK), nil

}

/*
TenantPropsUpdate updates tenant properties

This will update the properties of the tenant with the given id.
*/
func (a *Client) TenantPropsUpdate(params *TenantPropsUpdateParams, authInfo runtime.ClientAuthInfoWriter) (*TenantPropsUpdateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTenantPropsUpdateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "TenantPropsUpdate",
		Method:             "PUT",
		PathPattern:        "/tenantprops/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &TenantPropsUpdateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*TenantPropsUpdateOK), nil

}

/*
UpsertEvents upserts events

This will insert/update events for a tenant.
*/
func (a *Client) UpsertEvents(params *UpsertEventsParams, authInfo runtime.ClientAuthInfoWriter) (*UpsertEventsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpsertEventsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpsertEvents",
		Method:             "PUT",
		PathPattern:        "/events",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UpsertEventsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpsertEventsOK), nil

}

/*
UserCreate creates user

This will create a user.
*/
func (a *Client) UserCreate(params *UserCreateParams, authInfo runtime.ClientAuthInfoWriter) (*UserCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUserCreateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UserCreate",
		Method:             "POST",
		PathPattern:        "/users",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UserCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UserCreateOK), nil

}

/*
UserDelete deletes user

This will delete the user with the given id.
*/
func (a *Client) UserDelete(params *UserDeleteParams, authInfo runtime.ClientAuthInfoWriter) (*UserDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUserDeleteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UserDelete",
		Method:             "DELETE",
		PathPattern:        "/users/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UserDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UserDeleteOK), nil

}

/*
UserGet gets user

This will get the user with the given id.
*/
func (a *Client) UserGet(params *UserGetParams, authInfo runtime.ClientAuthInfoWriter) (*UserGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUserGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UserGet",
		Method:             "GET",
		PathPattern:        "/users/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UserGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UserGetOK), nil

}

/*
UserList lists users

This will retrieve all users for a tenant.
*/
func (a *Client) UserList(params *UserListParams, authInfo runtime.ClientAuthInfoWriter) (*UserListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUserListParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UserList",
		Method:             "GET",
		PathPattern:        "/users",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UserListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UserListOK), nil

}

/*
UserPropsDelete deletes user properties

This will delete the properties for the user with the given id.
*/
func (a *Client) UserPropsDelete(params *UserPropsDeleteParams, authInfo runtime.ClientAuthInfoWriter) (*UserPropsDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUserPropsDeleteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UserPropsDelete",
		Method:             "DELETE",
		PathPattern:        "/userprops/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UserPropsDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UserPropsDeleteOK), nil

}

/*
UserPropsGet gets user properties

This will get the properties for the user with the given id.
*/
func (a *Client) UserPropsGet(params *UserPropsGetParams, authInfo runtime.ClientAuthInfoWriter) (*UserPropsGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUserPropsGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UserPropsGet",
		Method:             "GET",
		PathPattern:        "/userprops/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UserPropsGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UserPropsGetOK), nil

}

/*
UserPropsUpdate updates user properties

This will update the properties of the user with the given id.
*/
func (a *Client) UserPropsUpdate(params *UserPropsUpdateParams, authInfo runtime.ClientAuthInfoWriter) (*UserPropsUpdateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUserPropsUpdateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UserPropsUpdate",
		Method:             "PUT",
		PathPattern:        "/userprops/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UserPropsUpdateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UserPropsUpdateOK), nil

}

/*
UserUpdateV2 updates user

This will update a user.
*/
func (a *Client) UserUpdateV2(params *UserUpdateV2Params, authInfo runtime.ClientAuthInfoWriter) (*UserUpdateV2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUserUpdateV2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UserUpdateV2",
		Method:             "PUT",
		PathPattern:        "/users/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UserUpdateV2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UserUpdateV2OK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
